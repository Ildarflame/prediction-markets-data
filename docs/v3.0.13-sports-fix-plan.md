# v3.0.13 "SPORTS Complete Fix" - Implementation Plan

## Summary

Комплексное исправление SPORTS pipeline для достижения >100 eligible Kalshi markets и реальных match suggestions.

**Цель:** Kalshi eligible > 100, suggestions > 10, precision > 80%

---

## Проблемы и решения

| # | Проблема | Причина | Решение |
|---|----------|---------|---------|
| 1 | 99% UNKNOWN league | SPORTS_KEYWORDS слишком широкие | Использовать `derivedTopic='SPORTS'` |
| 2 | 49% parlays excluded | Parlay detection слишком агрессивная | Уточнить parlay patterns |
| 3 | Event mismatch 1.7% | События не синхронизированы | Sync по eventTicker из markets |
| 4 | Team extraction errors | "Both Teams to Score" в имени | Улучшить regex cleanup |
| 5 | League misdetection | AVS→NHL, Rangers→MLB | Context-aware league detection |

---

## BLOCK A: Market Fetching по derivedTopic

### Проблема
```
SPORTS_KEYWORDS = ['vs', 'versus', ' @ ', ' at ', 'nba', 'nfl', ...]
```
"vs" матчит FOMC, elections, всё подряд → 99% UNKNOWN league.

### Решение
Использовать `derivedTopic = 'SPORTS'` вместо keyword matching для Kalshi.

### Изменения

**File: `services/worker/src/matching/pipelines/sportsPipeline.ts`**

```typescript
async fetchMarkets(repo: MarketRepository, options: FetchOptions): Promise<SportsMarket[]> {
  const { venue, lookbackHours = 720, limit = 10000 } = options;

  let markets;

  if (venue === 'kalshi') {
    // v3.0.13: Use derivedTopic instead of keywords for Kalshi
    markets = await repo.listMarketsByDerivedTopic('SPORTS', {
      venue: 'kalshi',
      lookbackHours,
      limit,
    });
  } else {
    // Polymarket: keep keyword matching (no derivedTopic yet)
    markets = await repo.listEligibleMarkets(venue, {
      lookbackHours,
      limit,
      titleKeywords: SPORTS_KEYWORDS,
    });
  }

  // ... rest of the function
}
```

**File: `packages/db/src/repositories/market.repository.ts`**

```typescript
async listMarketsByDerivedTopic(
  topic: string,
  options: { venue: Venue; lookbackHours?: number; limit?: number }
): Promise<EligibleMarket[]> {
  const { venue, lookbackHours = 720, limit = 10000 } = options;
  const lookbackCutoff = new Date(Date.now() - lookbackHours * 60 * 60 * 1000);

  const markets = await this.prisma.market.findMany({
    where: {
      venue,
      derivedTopic: topic,
      OR: [
        { status: 'active' },
        { status: 'closed', closeTime: { gte: lookbackCutoff } },
      ],
    },
    include: { outcomes: true },
    orderBy: { id: 'desc' },
    take: limit,
  });

  // Filter to binary markets
  return markets
    .filter(m => m.outcomes.length === 2)
    .filter(m => m.outcomes.some(o => o.side === 'yes') && m.outcomes.some(o => o.side === 'no'))
    .map(m => ({
      id: m.id,
      title: m.title,
      category: m.category,
      status: m.status,
      closeTime: m.closeTime,
      venue: m.venue,
      metadata: m.metadata as Record<string, unknown> | null,
      kalshiEventTicker: m.kalshiEventTicker,
    }));
}
```

### Ожидаемый результат
- Kalshi markets: 651K SPORTS → ~20K active/recent
- Исключены FOMC, elections и прочие non-sports

---

## BLOCK B: Умная Event Sync по Market eventTickers

### Проблема
```
kalshi:events:sync → 32,623 events (все серии)
Markets have eventTicker: 5,483 unique
Events found: 95 (1.7%)
```
Синхронизировали много событий, но не те что нужны markets.

### Решение
Sync events по eventTickers из существующих markets.

### Новая команда

**File: `services/worker/src/commands/kalshi-events-sync-smart.ts`**

```typescript
/**
 * Smart Kalshi Events Sync (v3.0.13)
 *
 * Синхронизирует только события, которые нужны существующим markets:
 * 1. Собирает уникальные eventTicker из markets.metadata
 * 2. Группирует по seriesTicker
 * 3. Запрашивает только нужные серии из API
 */

export interface SmartSyncOptions {
  venue?: 'kalshi';
  topic?: string;  // Filter by derivedTopic
  apply?: boolean;
  limit?: number;
}

export async function runKalshiEventsSmartSync(options: SmartSyncOptions) {
  // 1. Get unique eventTickers from markets
  const marketEventTickers = await prisma.$queryRaw<Array<{ eventTicker: string }>>`
    SELECT DISTINCT metadata->>'eventTicker' as "eventTicker"
    FROM markets
    WHERE venue = 'kalshi'
      AND metadata->>'eventTicker' IS NOT NULL
      ${options.topic ? Prisma.sql`AND derived_topic = ${options.topic}` : Prisma.empty}
    LIMIT ${options.limit || 50000}
  `;

  // 2. Extract unique seriesTickers
  const seriesTickers = new Set<string>();
  for (const { eventTicker } of marketEventTickers) {
    // KXNBA-25JAN23-LAL-BOS → KXNBA
    const match = eventTicker.match(/^([A-Z]+\d*[A-Z]*)/);
    if (match) seriesTickers.add(match[1]);
  }

  console.log(`Found ${marketEventTickers.length} eventTickers from ${seriesTickers.size} series`);

  // 3. Fetch events only for these series
  for (const seriesTicker of seriesTickers) {
    const events = await fetchEventsForSeries(baseUrl, seriesTicker);
    // ... upsert
  }

  // 4. Link markets to events
  await eventRepo.linkMarketsToEvents(!options.apply);
}
```

### CLI

```bash
kalshi:events:smart-sync --topic SPORTS --apply
```

### Ожидаемый результат
- Sync только релевантных серий (~50-100 вместо 1130)
- Event coverage: 1.7% → 80%+

---

## BLOCK C: Улучшенная Team Extraction

### Проблема
```
"Rangers FC vs. Kilmarnock FC: Both Teams to Score"
Teams: "rangers fc" vs "kilmarnock fc both teams to score"  ← WRONG
```

### Решение

**File: `packages/core/src/sports/teamExtract.ts`**

```typescript
// Suffixes to remove from team names
const TEAM_SUFFIXES_TO_REMOVE = [
  // Market type indicators
  'both teams to score',
  'btts',
  'end in a draw',
  'to win',
  'to score first',
  'to qualify',
  'over',
  'under',
  'spread',
  'handicap',
  'moneyline',
  'ml',

  // Time indicators
  'first half',
  'second half',
  '1st half',
  '2nd half',
  'full time',
  'ft',

  // Result indicators
  'win',
  'draw',
  'lose',
];

export function cleanTeamName(rawTeam: string): string {
  let team = rawTeam.toLowerCase().trim();

  // Remove suffixes
  for (const suffix of TEAM_SUFFIXES_TO_REMOVE) {
    if (team.endsWith(suffix)) {
      team = team.slice(0, -suffix.length).trim();
    }
    // Also try with colon
    const colonSuffix = `: ${suffix}`;
    if (team.endsWith(colonSuffix)) {
      team = team.slice(0, -colonSuffix.length).trim();
    }
  }

  // Remove trailing punctuation
  team = team.replace(/[:\-,]+$/, '').trim();

  return team;
}

export function extractTeams(title: string): { teamA: string; teamB: string } {
  // Split by "vs", "versus", " @ ", " at "
  const vsMatch = title.match(/(.+?)\s+(?:vs\.?|versus|@|at)\s+(.+)/i);
  if (!vsMatch) return { teamA: '', teamB: '' };

  const [, rawA, rawB] = vsMatch;

  return {
    teamA: cleanTeamName(rawA),
    teamB: cleanTeamName(rawB),
  };
}
```

### Тесты

```typescript
// extractTeams tests
test('removes "Both Teams to Score" suffix', () => {
  const { teamA, teamB } = extractTeams('Rangers FC vs. Kilmarnock FC: Both Teams to Score');
  assert.strictEqual(teamA, 'rangers fc');
  assert.strictEqual(teamB, 'kilmarnock fc');
});

test('removes "end in a draw" suffix', () => {
  const { teamA, teamB } = extractTeams('Will Barcelona SC vs. AA Argentinos Juniors end in a draw?');
  assert.strictEqual(teamA, 'barcelona sc');
  assert.strictEqual(teamB, 'aa argentinos juniors');
});
```

### Ожидаемый результат
- Team extraction accuracy: 60% → 95%+

---

## BLOCK D: Context-Aware League Detection

### Проблема
```
"AVS Futebol vs. SC Braga" → NHL (AVS = Avalanche)
"Rangers FC vs. Kilmarnock FC" → MLB (Rangers = Texas Rangers)
```

### Решение
Использовать контекст (страна, "FC", суффиксы) для определения лиги.

**File: `packages/core/src/sports/leagueDetect.ts`**

```typescript
// Football club indicators
const FOOTBALL_CLUB_INDICATORS = ['fc', 'cf', 'sc', 'ac', 'as', 'ss', 'afc', 'united', 'city', 'athletic', 'sporting'];

// Country/league mappings
const COUNTRY_LEAGUES: Record<string, SportsLeague> = {
  // Portuguese
  'portugal': SportsLeague.PRIMEIRA_LIGA,
  'benfica': SportsLeague.PRIMEIRA_LIGA,
  'porto': SportsLeague.PRIMEIRA_LIGA,
  'sporting': SportsLeague.PRIMEIRA_LIGA,
  'braga': SportsLeague.PRIMEIRA_LIGA,

  // Scottish
  'scotland': SportsLeague.SCOTTISH_PREM,
  'celtic': SportsLeague.SCOTTISH_PREM,
  'rangers fc': SportsLeague.SCOTTISH_PREM,  // Specific to avoid MLB Rangers
  'kilmarnock': SportsLeague.SCOTTISH_PREM,

  // Turkish
  'turkey': SportsLeague.SUPER_LIG,
  'galatasaray': SportsLeague.SUPER_LIG,
  'fenerbahce': SportsLeague.SUPER_LIG,
  'besiktas': SportsLeague.SUPER_LIG,
  'basaksehir': SportsLeague.SUPER_LIG,

  // ... more mappings
};

export function detectLeague(title: string, metadata?: Record<string, unknown>): SportsLeague {
  const titleLower = title.toLowerCase();

  // 1. Check explicit league mentions first
  if (/\bnba\b/.test(titleLower)) return SportsLeague.NBA;
  if (/\bnfl\b/.test(titleLower)) return SportsLeague.NFL;
  // ... etc

  // 2. Check for football club indicators
  const hasFootballIndicator = FOOTBALL_CLUB_INDICATORS.some(ind =>
    titleLower.includes(` ${ind} `) || titleLower.includes(` ${ind}`) || titleLower.endsWith(` ${ind}`)
  );

  if (hasFootballIndicator) {
    // 3. Try to identify specific league by team/country
    for (const [keyword, league] of Object.entries(COUNTRY_LEAGUES)) {
      if (titleLower.includes(keyword)) {
        return league;
      }
    }

    // 4. Default to generic football
    return SportsLeague.FOOTBALL;
  }

  // 5. Check metadata for hints
  if (metadata?.category?.toLowerCase().includes('soccer')) {
    return SportsLeague.FOOTBALL;
  }

  // 6. Try to detect US sports by team names
  // ...

  return SportsLeague.UNKNOWN;
}
```

### Новые лиги

```typescript
export enum SportsLeague {
  // Existing
  NBA = 'NBA',
  NFL = 'NFL',
  MLB = 'MLB',
  NHL = 'NHL',
  MLS = 'MLS',
  EPL = 'EPL',
  LA_LIGA = 'LA_LIGA',
  BUNDESLIGA = 'BUNDESLIGA',
  SERIE_A = 'SERIE_A',
  LIGUE_1 = 'LIGUE_1',

  // New in v3.0.13
  PRIMEIRA_LIGA = 'PRIMEIRA_LIGA',      // Portuguese
  SCOTTISH_PREM = 'SCOTTISH_PREM',      // Scottish
  SUPER_LIG = 'SUPER_LIG',              // Turkish
  EREDIVISIE = 'EREDIVISIE',            // Dutch
  BELGIAN_PRO = 'BELGIAN_PRO',          // Belgian
  CHAMPIONSHIP = 'CHAMPIONSHIP',         // English 2nd tier

  // Generic
  FOOTBALL = 'FOOTBALL',                 // Generic football/soccer

  // Existing
  UCL = 'UCL',
  EUROPA = 'EUROPA',
  UFC = 'UFC',
  ESPORTS = 'ESPORTS',
  UNKNOWN = 'UNKNOWN',
}
```

### Ожидаемый результат
- League detection accuracy: 30% → 85%+
- Proper FOOTBALL detection for European clubs

---

## BLOCK E: Relaxed Parlay Detection

### Проблема
```
49% excluded as "Multi-selection/parlay pattern detected"
Pattern: title.split(',').length > 2
```
Слишком агрессивно - матчит валидные рынки с запятыми.

### Решение

**File: `services/worker/src/matching/signals/sportsSignals.ts`**

```typescript
function shouldExcludeMarket(title: string): { excluded: boolean; reason: string | null } {
  const titleLower = title.toLowerCase();

  // ... existing keyword checks ...

  // UPDATED: More specific parlay detection
  // Old: title.split(',').length > 2
  // New: Check for actual parlay patterns

  const parlayPatterns = [
    /^yes\s+.+,\s*yes\s+/i,           // "Yes Lakers, Yes Celtics"
    /\+\s*\w+\s+\+/i,                  // "Lakers + Celtics + Warriors"
    /\band\b.*\band\b/i,               // "Lakers and Celtics and Warriors"
    /parlay|accumulator|combo|sgp/i,   // Explicit parlay keywords
    /\d+\s*-?\s*leg/i,                 // "3-leg parlay"
  ];

  for (const pattern of parlayPatterns) {
    if (pattern.test(titleLower)) {
      return { excluded: true, reason: 'Parlay pattern detected' };
    }
  }

  // Allow commas in normal context (e.g., "Rangers FC, Glasgow vs Celtic FC, Glasgow")
  // Only exclude if 3+ items that look like team names
  const commaSegments = title.split(',');
  if (commaSegments.length >= 3) {
    // Check if segments are team-like (contain "vs", team names, etc.)
    const teamLikeSegments = commaSegments.filter(seg =>
      /\bvs\b|team|win|score/i.test(seg)
    );
    if (teamLikeSegments.length >= 3) {
      return { excluded: true, reason: 'Multi-selection pattern' };
    }
  }

  return { excluded: false, reason: null };
}
```

### Ожидаемый результат
- Parlay exclusion: 49% → 15%
- More valid markets pass through

---

## BLOCK F: Debug Improvements

### Новые команды

```bash
# Show why specific markets are excluded
sports:debug --market-id 12345

# Compare signals between venues
sports:compare --left-id 12345 --right-id 67890

# Show event coverage stats
sports:event-coverage --topic SPORTS
```

### sports:event-coverage

```typescript
export async function runSportsEventCoverage(options: { topic?: string }) {
  // Count markets with eventTicker
  const withEventTicker = await prisma.market.count({
    where: {
      venue: 'kalshi',
      derivedTopic: options.topic,
      NOT: { metadata: { path: ['eventTicker'], equals: null } },
    },
  });

  // Count markets linked to events
  const linked = await prisma.market.count({
    where: {
      venue: 'kalshi',
      derivedTopic: options.topic,
      kalshiEventTicker: { not: null },
    },
  });

  // Count unique eventTickers in markets
  const uniqueTickers = await prisma.$queryRaw`
    SELECT COUNT(DISTINCT metadata->>'eventTicker') as count
    FROM markets
    WHERE venue = 'kalshi'
      AND derived_topic = ${options.topic}
  `;

  // Count matching events in DB
  const eventsInDb = await prisma.kalshiEvent.count();

  console.log(`
Event Coverage Report (${options.topic || 'all'})
================================
Markets with eventTicker:  ${withEventTicker}
Unique eventTickers:       ${uniqueTickers[0].count}
Events in DB:              ${eventsInDb}
Markets linked:            ${linked}
Coverage:                  ${((linked / withEventTicker) * 100).toFixed(1)}%
  `);
}
```

---

## Implementation Order

| Phase | Block | Description | Est. Complexity |
|-------|-------|-------------|-----------------|
| 1 | A | derivedTopic fetching | Low |
| 1 | B | Smart event sync | Medium |
| 2 | C | Team extraction fix | Low |
| 2 | D | League detection | Medium |
| 3 | E | Parlay detection | Low |
| 3 | F | Debug commands | Low |

---

## Files to Modify

**packages/core/src/**
- `sports/index.ts` - new exports
- `sports/teamExtract.ts` - improved extraction (NEW)
- `sports/leagueDetect.ts` - context-aware detection (NEW)
- `sports/types.ts` - new leagues

**packages/db/src/**
- `repositories/market.repository.ts` - listMarketsByDerivedTopic

**services/worker/src/**
- `matching/pipelines/sportsPipeline.ts` - use derivedTopic
- `matching/signals/sportsSignals.ts` - improved parlay detection
- `commands/kalshi-events-smart-sync.ts` - new command (NEW)
- `commands/sports-debug.ts` - add event-coverage
- `cli.ts` - register new commands

---

## Acceptance Criteria

| Metric | Before | Target |
|--------|--------|--------|
| Kalshi eligible | 4 | >100 |
| Polymarket eligible | 494 | >400 (maintain) |
| Event coverage | 1.7% | >60% |
| League accuracy | ~30% | >80% |
| Team extraction | ~60% | >90% |
| Match suggestions | ~4 | >20 |

---

## Verification Commands

```bash
# After Phase 1
kalshi:events:smart-sync --topic SPORTS --apply
sports:event-coverage --topic SPORTS
sports:eligible

# After Phase 2
sports:sample --venue kalshi --filter eligible --limit 20
sports:sample --venue polymarket --filter eligible --limit 20

# After Phase 3
sports:audit --venue kalshi --v2
v3:suggest-matches --topic SPORTS --from kalshi --to polymarket --dry-run
```

---

## Rollback Plan

Все изменения backward-compatible:
- `listMarketsByDerivedTopic` - новый метод, не ломает существующий
- `isEligibleSportsMarketV2` - уже существует, V1 остаётся
- New leagues - enum extension, не ломает existing

При проблемах можно откатить на v3.0.12 без миграций.
