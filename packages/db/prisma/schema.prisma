// This is your Prisma schema file
// Learn more at: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Supported prediction market venues
enum Venue {
  polymarket
  kalshi
}

// Canonical topics for cross-venue matching (v3.0.4)
enum CanonicalTopic {
  CRYPTO_DAILY
  CRYPTO_INTRADAY
  MACRO
  RATES
  ELECTIONS
  GEOPOLITICS
  SPORTS
  ENTERTAINMENT
  COMMODITIES   // v3.0.4: Oil, Gold, Agriculture futures
  UNKNOWN
}

// Market lifecycle status
enum MarketStatus {
  active
  closed
  resolved
  archived
}

// Outcome side in binary markets
enum OutcomeSide {
  yes
  no
  other
}

// Market link status for matching
enum LinkStatus {
  suggested
  confirmed
  rejected
}

// Market represents a tradeable prediction market
model Market {
  id              Int          @id @default(autoincrement())
  venue           Venue
  externalId      String       @map("external_id")
  title           String
  category        String?
  status          MarketStatus @default(active)
  statusMeta      Json?        @map("status_meta") @db.JsonB // Resolution info, status reason
  closeTime       DateTime?    @map("close_time") @db.Timestamptz
  sourceUpdatedAt DateTime?    @map("source_updated_at") @db.Timestamptz // Last update from source
  metadata        Json?        @db.JsonB
  derivedTopic    String?      @map("derived_topic") // v3.0.0: Computed canonical topic

  // v3.0.2: Polymarket taxonomy fields (from Gamma API)
  pmCategories       Json?     @map("pm_categories") @db.JsonB    // Array of {slug, label}
  pmTags             Json?     @map("pm_tags") @db.JsonB          // Array of {slug, label}
  pmEventCategory    String?   @map("pm_event_category")          // Event-level category
  pmEventSubcategory String?   @map("pm_event_subcategory")       // Event-level subcategory
  taxonomySource     String?   @map("taxonomy_source")            // PM_EVENT_TAGS, PM_SPORTS, TITLE, HEURISTIC

  // v3.0.3: Link to Polymarket event for taxonomy
  pmEventId          String?   @map("pm_event_id")                // Gamma event ID (not FK, just reference)

  // v3.0.4: Cached event fields for efficient taxonomy lookup
  pmEventTitle       String?   @map("pm_event_title")             // Cached from polymarket_events
  pmEventSlug        String?   @map("pm_event_slug")              // Cached from polymarket_events
  pmEventTagSlugs    String[]  @default([]) @map("pm_event_tag_slugs")  // Cached tag slugs for fast lookup

  // v3.0.12: Kalshi event reference for SPORTS matching
  kalshiEventTicker  String?   @map("kalshi_event_ticker")        // Reference to kalshi_events.event_ticker

  createdAt       DateTime     @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime     @updatedAt @map("updated_at") @db.Timestamptz

  outcomes       Outcome[]
  leftLinks      MarketLink[]     @relation("LeftMarketLinks")
  rightLinks     MarketLink[]     @relation("RightMarketLinks")
  quoteWatchlist QuoteWatchlist[]

  @@unique([venue, externalId])
  @@index([status, closeTime])
  @@index([derivedTopic])
  @@index([pmEventId])
  @@index([kalshiEventTicker])
  @@map("markets")
}

// Outcome represents a possible result of a market
model Outcome {
  id         Int         @id @default(autoincrement())
  marketId   Int         @map("market_id")
  externalId String?     @map("external_id")
  name       String
  side       OutcomeSide
  metadata   Json?       @db.JsonB
  createdAt  DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime    @updatedAt @map("updated_at") @db.Timestamptz

  market      Market       @relation(fields: [marketId], references: [id], onDelete: Cascade)
  quotes      Quote[]
  latestQuote LatestQuote?

  @@unique([marketId, name])
  @@index([marketId])
  @@map("outcomes")
}

// Quote is append-only price history
model Quote {
  id          BigInt   @id @default(autoincrement())
  outcomeId   Int      @map("outcome_id")
  ts          DateTime @db.Timestamptz
  price       Float
  impliedProb Float    @map("implied_prob")
  liquidity   Float?
  volume      Float?
  raw         Json?    @db.JsonB // Raw data from source for debugging
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  outcome Outcome @relation(fields: [outcomeId], references: [id], onDelete: Cascade)

  @@index([outcomeId, ts(sort: Desc)])
  @@map("quotes")
}

// LatestQuote is a materialized view of the most recent quote per outcome
model LatestQuote {
  id          Int      @id @default(autoincrement())
  outcomeId   Int      @unique @map("outcome_id")
  ts          DateTime @db.Timestamptz
  price       Float
  impliedProb Float    @map("implied_prob")
  liquidity   Float?
  volume      Float?
  raw         Json?    @db.JsonB // Raw data from source for debugging
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  outcome Outcome @relation(fields: [outcomeId], references: [id], onDelete: Cascade)

  @@index([outcomeId])
  @@map("latest_quotes")
}

// IngestionState tracks checkpoint data for incremental ingestion
model IngestionState {
  id            Int       @id @default(autoincrement())
  venue         Venue
  jobName       String    @map("job_name")
  cursor        String?
  watermarkTs   DateTime? @map("watermark_ts") @db.Timestamptz
  lastSuccessAt DateTime? @map("last_success_at") @db.Timestamptz
  lastError     String?   @map("last_error")
  statsJson     Json?     @map("stats_json") @db.JsonB
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  @@unique([venue, jobName])
  @@index([venue, jobName])
  @@map("ingestion_state")
}

// IngestionRun is an audit log of each ingestion execution
model IngestionRun {
  id            Int       @id @default(autoincrement())
  venue         Venue
  jobName       String    @default("ingest") @map("job_name") // 'markets', 'quotes', 'ingest'
  startedAt     DateTime  @map("started_at") @db.Timestamptz
  finishedAt    DateTime? @map("finished_at") @db.Timestamptz
  ok            Boolean   @default(false)
  fetchedCounts Json?     @map("fetched_counts") @db.JsonB
  writtenCounts Json?     @map("written_counts") @db.JsonB
  warningsJson  Json?     @map("warnings_json") @db.JsonB
  errorText     String?   @map("error_text")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz

  @@index([venue, jobName, startedAt(sort: Desc)])
  @@map("ingestion_runs")
}

// MarketLink stores matched market pairs between venues
model MarketLink {
  id            Int        @id @default(autoincrement())
  leftVenue     Venue      @map("left_venue")
  leftMarketId  Int        @map("left_market_id")
  rightVenue    Venue      @map("right_venue")
  rightMarketId Int        @map("right_market_id")
  status        LinkStatus @default(suggested)
  score         Float
  reason        String?
  /// v2.6.2: Algorithm version that created/updated this suggestion (e.g., "crypto_daily@2.6.2")
  algoVersion   String?    @map("algo_version")
  /// v2.6.3: Topic that this link belongs to (e.g., "crypto_daily", "crypto_intraday", "macro")
  topic         String?
  createdAt     DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime   @updatedAt @map("updated_at") @db.Timestamptz

  leftMarket  Market @relation("LeftMarketLinks", fields: [leftMarketId], references: [id], onDelete: Cascade)
  rightMarket Market @relation("RightMarketLinks", fields: [rightMarketId], references: [id], onDelete: Cascade)

  @@unique([leftVenue, leftMarketId, rightVenue, rightMarketId])
  @@index([status, score(sort: Desc)])
  @@index([leftVenue, rightVenue])
  @@index([algoVersion])
  @@index([topic])
  @@map("market_links")
}

// v2.6.7: QuoteWatchlist - Markets to actively fetch quotes for
// Instead of trying to quote all 1.2M markets, we target specific ones
model QuoteWatchlist {
  id        Int      @id @default(autoincrement())
  venue     Venue
  marketId  Int      @map("market_id")
  priority  Int      @default(0) // Higher = more important (100=confirmed, 50=top_suggested, 0=manual)
  reason    String   // "confirmed_link", "top_suggested", "manual"
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  market Market @relation(fields: [marketId], references: [id], onDelete: Cascade)

  @@unique([venue, marketId])
  @@index([venue, priority(sort: Desc)])
  @@index([reason])
  @@map("quote_watchlist")
}

// ============================================================
// Taxonomy Tables (v3.0.0)
// ============================================================

// KalshiSeries - Cached series metadata from Kalshi API
model KalshiSeries {
  id         Int      @id @default(autoincrement())
  ticker     String   @unique
  title      String
  category   String?
  frequency  String?
  tags       String[] @default([])
  lastSyncAt DateTime @map("last_sync_at") @db.Timestamptz
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@index([category])
  @@map("kalshi_series")
}

// KalshiTag - Aggregated tag counts from Kalshi series
model KalshiTag {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  seriesCount Int      @default(0) @map("series_count")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@map("kalshi_tags")
}

// PolymarketTag - Extracted tags from Polymarket markets
model PolymarketTag {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  source      String   // "category" | "groupItemTitle"
  marketCount Int      @default(0) @map("market_count")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@map("polymarket_tags")
}

// TopicMap - Mapping from venue-specific topics to canonical topics
model TopicMap {
  id             Int            @id @default(autoincrement())
  venue          Venue
  venueTopic     String         @map("venue_topic")
  canonicalTopic CanonicalTopic @map("canonical_topic")
  confidence     Float          @default(1.0)
  source         String         @default("manual") // "manual" | "auto" | "rule"
  enabled        Boolean        @default(true)
  createdAt      DateTime       @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime       @updatedAt @map("updated_at") @db.Timestamptz

  @@unique([venue, venueTopic])
  @@index([canonicalTopic])
  @@map("topic_map")
}

// ============================================================
// Polymarket Events (v3.0.3)
// ============================================================

// PolymarketEvent - Cached event metadata from Gamma API
// Events contain markets and have proper taxonomy tags
model PolymarketEvent {
  id            Int      @id @default(autoincrement())
  externalId    String   @unique @map("external_id")  // Gamma event ID
  slug          String
  title         String
  category      String?                               // Event-level category (e.g., "Sports")
  tags          Json?    @db.JsonB                    // Array of {id, slug, label}
  seriesId      String?  @map("series_id")            // Link to series if present
  seriesSlug    String?  @map("series_slug")
  active        Boolean  @default(true)
  closed        Boolean  @default(false)
  volume        Float?
  liquidity     Float?
  marketCount   Int      @default(0) @map("market_count")
  lastSyncAt    DateTime @map("last_sync_at") @db.Timestamptz
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@index([category])
  @@index([active, closed])
  @@map("polymarket_events")
}

// PolymarketSport - Sports configuration from Gamma API
// Maps series to sports/leagues for sports detection
model PolymarketSport {
  id         Int      @id @default(autoincrement())
  sport      String   @unique                         // e.g., "nba", "nfl", "epl"
  seriesIds  String[] @default([]) @map("series_ids") // Series IDs that belong to this sport
  tagIds     String[] @default([]) @map("tag_ids")    // Tag IDs for this sport
  image      String?
  resolution String?
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@map("polymarket_sports")
}

// ============================================================
// Kalshi Events (v3.0.12)
// ============================================================

// KalshiEvent - Cached event metadata from Kalshi API
// Events are the grouping level between series and markets
// Critical for SPORTS matching: contains team names and strike dates
model KalshiEvent {
  id           Int       @id @default(autoincrement())
  eventTicker  String    @unique @map("event_ticker")   // e.g., "KXNBA-25JAN23-LAL-BOS"
  seriesTicker String    @map("series_ticker")          // e.g., "KXNBA"
  title        String                                    // e.g., "Lakers vs Celtics"
  subTitle     String?   @map("sub_title")              // e.g., "January 23, 2025"
  category     String?
  status       String?                                   // "open", "closed", "settled"
  strikeDate   DateTime? @map("strike_date") @db.Timestamptz  // Event date/time
  mutuallyExclusive Boolean @default(false) @map("mutually_exclusive")  // MVE flag
  marketCount  Int       @default(0) @map("market_count")
  lastSyncAt   DateTime  @map("last_sync_at") @db.Timestamptz
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  @@index([seriesTicker])
  @@index([strikeDate])
  @@index([status])
  @@map("kalshi_events")
}
